import meshio
import dolfin
from dolfin.io import XDMFFile
import numpy as np
from ufl import SpatialCoordinate, inner, grad, lhs, rhs, exp, dx, ds
from dolfin import FunctionSpace, TrialFunction, TestFunction, DirichletBC
from dolfin import Function, solve, MPI

# Read the file generated by gmsh
mesh = meshio.read("poission_subdomain.msh")

points, cells = mesh.points, mesh.cells
cell_data, field_data = mesh.cell_data, mesh.field_data

meshio.write("ps_mesh.xdmf",
             meshio.Mesh(
                points=points[:, :2],  # Converting to 2D
                cells={"triangle": cells["triangle"]},
                cell_data={"triangle": {"subdomain": cell_data["triangle"]
                                        ["gmsh:physical"]}},
                field_data=field_data))

meshio.write("ps_boundary.xdmf", meshio.Mesh(
    points=points[:, :2],  # Converting to 2D
    cells={"line": cells["line"]},
    cell_data={"line": {"boundaries": cell_data["line"]["gmsh:physical"]}}
))

with XDMFFile(MPI.comm_world, "ps_mesh.xdmf") as xdmf_infile:
    mesh = xdmf_infile.read_mesh(dolfin.cpp.mesh.GhostMode.none)
    mvc_subdomain = xdmf_infile.read_mvc_size_t(mesh, "subdomain")
    tag_info = xdmf_infile.read_information_int()

with XDMFFile(MPI.comm_world, "ps_boundary.xdmf") as xdmf_infile:
    mvc_boundaries = xdmf_infile.read_mvc_size_t(mesh, "boundaries")

print("Constructing MeshFunction from MeshValueCollection")
mf_triangle = dolfin.cpp.mesh.MeshFunctionSizet(mesh, mvc_subdomain, 0)
mf_line = dolfin.cpp.mesh.MeshFunctionSizet(mesh, mvc_boundaries, 0)

a0 = 1.0
a1 = 0.01
x = SpatialCoordinate(mesh)
g_L = exp(- 10*(- pow(x[1] - 0.5, 2)))
g_R = 1.0
f = 1.0

# Define function space and basis functions
V = FunctionSpace(mesh, ("CG", 2))
u = TrialFunction(V)
v = TestFunction(V)

u5 = Function(V)
with u5.vector().localForm() as bc_local:
    bc_local.set(5.0)

u0 = Function(V)
with u0.vector().localForm() as bc_local:
    bc_local.set(0.0)


# Define Dirichlet boundary conditions at top and bottom boundaries
bcs = [DirichletBC(V, u5, np.where(mf_line.values == tag_info['TOP'])[0]),
       DirichletBC(V, u0, np.where(mf_line.values == tag_info['BOTTOM'])[0])]

dx = dx(subdomain_data=mf_triangle)
ds = ds(subdomain_data=mf_line)

# Define variational form
F = (inner(a0*grad(u), grad(v))*dx(tag_info['DOMAIN']) +
     inner(a1*grad(u), grad(v))*dx(tag_info['OBSTACLE']) -
     g_L*v*ds(tag_info['LEFT']) -
     g_R*v*ds(tag_info['RIGHT']) -
     f*v*dx(tag_info['DOMAIN']) -
     f*v*dx(tag_info['OBSTACLE']))


# Separate left and right hand sides of equation
a, L = lhs(F), rhs(F)

# Solve problem
u = Function(V)
solve(a == L, u, bcs)

with XDMFFile(dolfin.MPI.comm_world, "output.xdmf") as xdmf_outfile:
    xdmf_outfile.write(u)
